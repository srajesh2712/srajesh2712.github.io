[{"content":"I’ve been diving deep into Go lately, and the transition from a traditional OOP/Spring background has been a total paradigm shift. Coming from a world of rigid \u0026ldquo;Classes\u0026rdquo; and deep \u0026ldquo;Inheritance\u0026rdquo; trees, Go’s approach felt alien at first—until the logic finally clicked.\nThe Shift: Modules over Hierarchies In Go, the philosophy is simple: Go doesn’t have classes. Instead, it relies on two powerful pillars:\nComposition (Struct Embedding) Implicit Interfaces Here’s the journey of how I built a \u0026ldquo;Vehicle System\u0026rdquo; from scratch and why this \u0026ldquo;horizontal\u0026rdquo; way of building software is winning me over. 1. The Hierarchy: Composition over Inheritance In Go, we don\u0026rsquo;t say a Car is a Vehicle. We say a Car is composed of a Vehicle. Using Struct Embedding, I built a modular hierarchy:\nEngine: Core data (Model/Year). Vehicle: Shared logic (Speed/Type) embedding the Engine. Aeroplane: A specialized wrapper embedding the Vehicle. The \u0026ldquo;Wow\u0026rdquo; Moment: Method Promotion. Because Aeroplane embeds Vehicle, it can call .Start() automatically, but it keeps its unique behaviors like .Takeoff() separate.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 type Engine struct { model string makeyear string } type Vehicle struct { Engine speed float64 vehType string } type Aeroplane struct { Vehicle } 2. Reducing Boilerplate with Factory Functions Go doesn’t have constructors, but the idiomatic \u0026ldquo;New\u0026rdquo; pattern is a game changer. I implemented Factory Functions (like NewAeroplane) to encapsulate initialization. This keeps the main logic clean and ensures that every object is \u0026ldquo;born\u0026rdquo; in a valid state.\n1 2 3 4 5 6 func NewVehicle(model string, speed float64, vehType string) *Vehicle { return \u0026amp;Vehicle{Engine: Engine{model, strconv.Itoa(2026)}, speed: speed, vehType: vehType} } func NewAeroplane(model string, speed float64) *Aeroplane { return \u0026amp;Aeroplane{Vehicle: *NewVehicle(model, speed, \u0026#34;aeroplane\u0026#34;)} } 3. The Power of \u0026ldquo;Implicit\u0026rdquo; Interfaces This was the biggest bridge for me as a Spring developer. In Spring, you explicitly implement an interface. In Go, if your struct has the method, it is the interface.\nI defined a Drivable interface:\n1 2 3 type Drivable interface { Start() } Because my structs had a Start() method, I could create a Fleet (a slice of interfaces). I could iterate through Cars and Aeroplanes in one loop, triggering their specific logic without the objects ever knowing about the interface!\n4. The Golden Rule: \u0026ldquo;Accept Interfaces, Return Structs\u0026rdquo; During this transition, I learned the \u0026ldquo;Golden Rule\u0026rdquo; of Go design that keeps your codebase flexible yet powerful:\nReturn Structs: In your constructors (factory functions), return the concrete type. This ensures the caller gets the full \u0026ldquo;power\u0026rdquo; of the object (like an Aeroplane\u0026rsquo;s specific Takeoff() method). Accept Interfaces: In your high-level logic or functions, accept an interface. This keeps your functions decoupled and makes your code incredibly \u0026ldquo;testable.\u0026rdquo; Why this beats traditional inheritance:\nDecoupling: I can swap a V8Engine for an ElectricEngine without rewriting the Aeroplane logic. Testability: Mocking becomes trivial. No heavy \u0026ldquo;Mockito magic\u0026rdquo; is required—just a simple struct that satisfies the interface. Clarity: The boundaries are strict. A Vehicle can’t accidentally call Takeoff(), preventing the \u0026ldquo;leaky abstraction\u0026rdquo; common in Java. The Key Takeaway: Embracing \u0026ldquo;Idiomatic\u0026rdquo; Go Writing Go means moving away from deep, rigid class trees and embracing flat, horizontal structures. It feels like \u0026ldquo;Manual Dependency Injection,\u0026rdquo; and the result is code that is:\nEasier to maintain. Faster to compile. Much harder to break during refactoring. For the Java/Spring developers out there: Are you favoring the \u0026ldquo;Magic\u0026rdquo; of a framework or the \u0026ldquo;Explicit\u0026rdquo; nature of Go in your current projects? Let’s discuss in the comments!\n#Golang #Programming #SoftwareEngineering #CleanCode #BackendDevelopment #JavaToGo #CloudNative\nOriginally published on LinkedIn\n","permalink":"https://srajesh2712.github.io/posts/2026/03/01/golan-composition-vs-inheritance/","summary":"Why moving from Java/Spring to Go feels like trading a complex hierarchy for a modular Lego set.","title":"Is it Inheritance? No, it’s Composition (The Go Way)"},{"content":"How many times have you looked at a piece of code and thought, \u0026ldquo;This should be faster\u0026rdquo;?\nRecently, I went on a journey of optimizing a process that was taking 3 seconds and managed to bring it down to 0.0002 seconds. That\u0026rsquo;s a 150,000x improvement. But the real story isn\u0026rsquo;t just the final number—it\u0026rsquo;s what I broke along the way to get there.\nThe Challenge: Last-In, First-Out (LIFO) The goal was simple: Reverse a string of 34,000 characters. To make it interesting, I benchmarked each approach by running the operation 1,000 times.\nPhase 1: The Pythonic Way Initially, I was doing what most of us do: focusing on readability and standard library functions. It worked, but at scale, it crawled.\nclass Stack: def init(self): self.items = []\ndef is_empty(self): #return len(self.items) == 0 return not self.items def push(self, item): self.items.append(item) def pop(self): return self.items.pop() def peek(self): return self.items[-1] def size(self): return len(self.items) def __str__(self): return str(self.items) The Lesson: I quickly discovered the \u0026ldquo;String Concatenation Trap.\u0026rdquo; Using += to build the result string in Python is O(n2) because strings are immutable; every addition creates a copy. By switching to a list-based accumulator and \u0026ldquo;\u0026quot;.join(), I brought the time down significantly.\nFinal Python Time: ~3.16 seconds. def reverse_string_slow(my_string): reversed_string = \u0026quot;\u0026rdquo;\n# Create a new stack s = Stack() # Iterate through my_string and push the characters onto the stack for char in my_string: s.push(char) # Use a while loop with the exit condition that the stack is empty. # Within this loop, update reversed_string with characters popped off the stack. while not s.is_empty(): reversed_string += s.pop() #return reversed_string The Faster approach def reverse_string_fast(my_string): reversed_string = \u0026quot;\u0026quot;\n# Create a new stack s = Stack() # Iterate through my_string and push the characters onto the stack for char in my_string: s.push(char) # Use a while loop with the exit condition that the stack is empty. # Within this loop, update reversed_string with characters popped off the stack. accumulator = [] while not s.is_empty(): accumulator.append(s.pop()) return \u0026quot;\u0026quot;.join(accumulator) Phase 2: The Go Evolution (The Crash) Moving to Go, I wanted to see how a compiled language handled the same Stack logic. I built a struct with Push and Pop methods.\nThe Lesson: I learned about \u0026ldquo;The Ghost Pop.\u0026rdquo; In my first attempt, I returned the top item but forgot to re-slice the underlying array.\nResult: An infinite loop that allocated memory so fast it crashed my machine! The Fix: s.items = s.items[:lastIdx] — strictly managing the slice length is the key to Go’s efficiency. func (s *Stack) Pop() rune { if len(s.items) == 0 { return 0 } lastIdx := len(s.items) - 1 item := s.items[lastIdx] s.items = s.items[:lastIdx] return item }\nThe Pointer Swap version i followed to check the stats instead of Stack.\nfunc (s *Stack) reverse() string { runes := []rune(s.str) n := len(runes) j := n - 1 for i := 0; i \u0026lt; n/2; i++ { runes[i], runes[j-i] = runes[j-i], runes[i] } return string(runes) }\nPhase 3: The Ultimate Optimization (The Swap) Finally, I moved away from the Stack entirely. Instead of moving data into a container, I used a Two-Pointer Swap directly on a slice of runes. This mirrored the indices from the outside-in.\nKey Insights - The \u0026quot;Allocation\u0026quot; Hidden Cost: While the Go Stack and the Go Swap were similar in speed, the Stack used 4.6x more memory and required 21x more interactions with the OS (allocations). In a high-traffic production environment, the Swap version is the clear winner for stability. - Stateless vs. Stateful: The \u0026quot;Swap\u0026quot; method is stateless and O(1) extra space, making it a \u0026quot;Senior\u0026quot; approach to a \u0026quot;Junior\u0026quot; problem. - The Performance Gap: Go finished in nanoseconds what Python finished in seconds. For data-heavy tasks, the difference is night and day. Final Thoughts Whether you are building a Neural Network or a simple string utility, understanding how your language manages memory is the difference between code that \u0026ldquo;works\u0026rdquo; and code that \u0026ldquo;scales.\u0026rdquo;\nDon\u0026rsquo;t just write code—measure it.\n#SoftwareEngineering #Golang #Python #Performance #Programming #DataStructures #ComputerScience\nOriginally published on LinkedIn\n","permalink":"https://srajesh2712.github.io/posts/2026/02/optimizing-my-ram/","summary":"A deep dive into how I optimized a critical process by 150,000x and the hard lessons learned about memory management.","title":"From 3 Seconds to 0.0002s: What I Learned Breaking My RAM"},{"content":"Hello, I\u0026rsquo;m Rajesh Subramanian Passionate developer coming from Electrical And Electronics Engineering.\nUnderstands the computer language beyond bytes at the electrical/electronics circuit level.\nPolygot developer with proficiency on various ecosystem.\nBigdata engineer\nAI / ML Engineer\nI bridge the gap between Software Engineering and Earth Observation. My work focuses on building scalable, distributed systems that process massive geospatial datasets in near-real-time.\nWhat I\u0026rsquo;m Currently Building SAR Flood Pipelines: Developing end-to-end pipelines for Sentinel-1 (GRD/SLC) data using Apache Sedona and Spark. Biomass Monitoring: Scaling SAR-optical data fusion to monitor global vegetation health. EO-Ops: Implementing reproducible, automated workflows for the research community using Airflow and Docker. **ML Models ** Building models on various neural networks. Tech Stack Big Data Backends \u0026amp; Frameworks Databases \u0026amp; Streaming Cloud \u0026amp; Devops Frontend AI \u0026amp; Vector Search --- Want to see the full story? I\u0026rsquo;ve documented my 20-year transition from monolithic Java development to modern Lakehouse architectures.\nView My Architectural Journey →\n","permalink":"https://srajesh2712.github.io/about/","summary":"Data Engineer \u0026amp; Remote Sensing Researcher specializing in Big Data \u0026amp; Geospatial Analytics","title":"About Me"},{"content":"The Architectural Evolution (2006 — Present) I view my career not just as a list of jobs, but as a series of architectural shifts. Each era represents a new challenge in how we handle data and scale.\n2026 - AI-Data Interoperability (MCP) Scaling the Model Context Protocol (MCP) to bridge the gap between LLMs and secure Data Lakes, enabling AI agents to interact with Petabyte-scale datasets safely.\nMCP AI Agents Semantic Data Layers 2024 - Lakehouse \u0026 Modern Data Stack Bridging the gap between Data Warehouses and Data Lakes. Implementing open table formats for high-performance ACID transactions on object storage.\nApache IcebergKafka Streaming Dask Data Governance 2022 - Data Engineering \u0026 Streaming Pivoted to real-time event-driven architectures and distributed computing to handle high-velocity streaming and Petabyte-scale challenges.\nActive MQ Spark Hadoop Kubernetes GoAirflow 2018 - AI \u0026 Machine Learning Integrated predictive power into applications, moving from standard logic to Deep Learning and Graph-based relationship modeling.\nPython CNN GNN Neural Networks PyTorch/TF 2015 - Microservices Led the migration from modular application to microservices.\nSpring Boot Microservices 2012 - Cloud Transformation Led the migration from on-premise hardware to elastic cloud environments, optimizing for high availability and global scale.\nAWS / Google Cloud SQL / NoSQL 2010 - Enterprise Modularization Transitioned from rigid monoliths to modular \"Shared Nothing\" architectures. Focused on decoupled data access and the early Spring ecosystem to improve team velocity.\nSpring Framework Modular Monoliths Hibernate BPELWebservices 2008 - Enterprise Frameworks Adopted the Spring ecosystem to handle complex enterprise requirements and \"Rich Internet Application\" (RIA) frontends.\nSpring Framework Struts Hibernate Flex/ActionScript 2006 - Monolithic Era The foundation: Building robust, server-side rendered web applications with core Java and relational database design.\nJava EEEJB JSP Servlets RDBMS(Oracle/MySQL) Perspective: Coming from an Electrical and Electronics Engineering background, I\u0026rsquo;ve always viewed software through the lens of signal processing and circuit efficiency. This \u0026ldquo;low-level\u0026rdquo; understanding helps me optimize Big Data pipelines where every byte and millisecond counts.\n","permalink":"https://srajesh2712.github.io/journey/","summary":"Two decades of evolution: From Monoliths to Lakehouses","title":"My Journey"}]